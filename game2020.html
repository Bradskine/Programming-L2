<!doctype html>

<body>
    <canvas id="gameCanvas" width="700" height="600"></canvas>
    <script>
        var canvas, ctx;

        window.onload = function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            setInterval(mainloop, 1000 / 50);

            document.addEventListener('keydown', keyPressed); // checks for the keys.
            document.addEventListener('keyup', keyReleased);

            canvas.addEventListener('mousemove', function(evt) {

                var mousePos = mouseAction(evt);
                mouseX = mousePos.x;
                mouseY = mousePos.y;
            });

        }


        var mouseX, mouseY;

        var paddleXpos = 0;
        var paddleYpos = 0;
        const PADDLE_WIDTH = 90;
        const PADDLE_HEIGHT = 20;
        var paddleXspeed = 10;
        var paddleYspeed = 5;
        var paddleColor = 'black';
        var gameStart = false;

        //ball variables

        //               var ballXpos = 0;
        //               var ballXpos = 0;
        //             var ballYpos = 0;
        var ballDiameter = 30;
        //        var ballXspeed = 50;
        var balls = [];
        var ballCount = 0;
        var ballMaxCount = 0;
        var a = 0;
        var b = 2 * Math.PI;
        var ballYspeed = 5;
        var ballBaseSpeed = 5
        var ballColor = 'red';
        var ballActive = false;


        //for arrow and wasd keys 
        const WKEY = 87;
        const AKEY = 65;
        const SKEY = 83;
        const DKEY = 68;
        const LEFT_KEY = 37;
        const TOP_KEY = 38;
        const RIGHT_KEY = 39;
        const BOT_KEY = 40;
        var upKeyPressed = false;
        var rightKeyPressed = false;
        var leftKeyPressed = false;
        var downKeyPressed = false;


        //images 


        var ball2 = new Image();
        var brickImg = new Image();
        var powerUp = new Image();
        ball2.src = 'Img/ball.png';
        brickImg.src = 'Img/brick.png';




        //bricks variables
        var bricks = [];
        var brickCount = 0;
        var brickMaxCount = 0; //in mainloop is based of rowCount times rowWidth
        var brickWidth = 40;
        var brickSpace = 0;
        var brickHeight = 50;
        var brickXpos = 0;
        var brickYpos = 0;
        var brickStrength = 0;

        var brickTopGap = 50;
        var brickXgap = 7;
        var brickYgap = 2;
        var rowCount = 1;
        var rowMaxCount = 0;
        var columnCount = 1;
        var columnMaxCount = 0;


        //powerup variables 
        var puWidth = 0;


        // general game variables
        var score = 0;
        var lifes = 3;
        var level = 0;
        var gameActive = false;
        var difficulty = 'normal'

        //        var name = prompt("What's your name") // ask for the name
        //        while (name.length == 0 || name == 'null') { // if the names lenght is 0 or the player clicks cancel it will keep asking until they type a valid name.
        //            alert("Your name must be more than one character");
        //            name = prompt("What's your name?");
        //        }
        //        var difficulty = prompt("What difficulty do you want to play at, Easy, Normal or Hard", 'Normal') // ask for difficulty.
        //        if (difficulty == null) { // checks they did'nt click null because if I check in next loop it cannot read .toLowerCase() of null.
        //            difficulty = prompt("What difficulty do you want to play at, Easy, Normal or Hard")
        //        }
        //        while (difficulty.toLowerCase() !== 'easy' && difficulty.toLowerCase() !== 'normal' && difficulty.toLowerCase() !== 'hard') { //makes sure they typre hard, normal or easy. Uses .toLowerCase so it doesn't matter if the user uses capital letters or not.
        //            difficulty = prompt("What difficulty do you want to play at, Easy, Normal or Hard")
        //            if (difficulty == null) {
        //                difficulty = prompt("What difficulty do you want to play at, Easy, Normal or Hard")
        //            }
        //        }
        //        alert("Hi " + name + " Hope you enjoy my game move the paddle with mouse or keys");

        function mainloop() {
            colorRect(0, 0, canvas.width, canvas.height, 'grey'); // bg

            if (gameStart == false) {
                paddleXpos = canvas.width / 2 - PADDLE_WIDTH / 2; //sets variables for when game first starts to make paddle in middle
                paddleYpos = canvas.height * 0.90;
                score = 0;
                if (difficulty == 'easy') { //sets difficutly based on prompts
                    lifes = 5;
                } else if (difficulty == 'normal') {
                    lifes = 3;
                } else {
                    lifes = 1
                }

                gameStart = true;



            }



            drawPaddle(); //funciotns to create draw and make paddle move
            paddleMove();



            drawScore();
            drawBalls();
            ballMove();
            drawBricks();
            updateLevel();
            gameOver();

        }






        function updateLevel() { //to create the new levels 






            if (level == 0) {
                ballMaxCount = 2;

                pushBall();
                brickTopGap = 50; //updates levels by changing brick variables and ball variables
                brickXgap = 7;
                brickYgap = 2;

                rowMaxCount = 2;

                columnMaxCount = 5; //sets variables for start of level so doesn't overied them when new level starts
                brickStrength = 1


                ballDiameter = 30;

                brickSpace = 0;
                //                newLevel();

                newLevel();
            }



            if (level > 0 && brickCount <= 0) { // changes the speed based on the level so gets faster as game goes on



                if (level == 1) { //changes stuff for each levels
                    //                    brickSpace = brickWidth + brickXgap;

                    rowMaxCount = 3;
                    columnMaxCountCount = 5;

                    brickStrength = 1

                } else if (level == 2) { // changes variables based on what level it is
                    rowMaxCount = 4;
                    columnMaxCount = 6;
                    brickStrength = 2;
                } else if (level == 3) {

                    brickXgap = 2;
                    brickYgap = 1;
                    rowMaxCount = 5;
                    columnMaxCount = 7;
                    brickStrength = 3

                    pushBall();
                } else {
                    rowMaxCount = Math.floor(1.4 * level + 1); // to make it so in very high leves brick count will get larger but bricks wont get to skinny
                    columnMaxCount = level + 4;

                }

                newLevel();



            }


        } //end of update level function


        function rand() {
            brickStrength = Math.floor(Math.random() * (3 - 1) + 1);
        }

        function pushBall() {
            while (ballCount < ballMaxCount) { // pushs new ball based of its own varibles. Made it sepearte function too save line mimize glitch chance
                balls.push(newBall());

            }
        }


        function newLevel() { //fuction for new level

            brickMaxCount = rowMaxCount * columnMaxCount;

            while (brickCount < brickMaxCount) {
                bricks.push(addBrick());
            }



            balls.forEach(function(balls, index, array) {
                if (balls.ballYspeed > 0) {
                    balls.ballYspeed = ballBaseSpeed + (level * 2);
                } else {
                    balls.ballYspeed = -(ballBaseSpeed + (level * 2));
                }


            });

            level += 1;
        }

        function drawBricks() { //to draw the brikcs



            var counter = 0;
            bricks.forEach(function(brick) { //uese for each so can have muitiple on page at 1 time
                counter++;
                balls.forEach(function(ball) {


                    if (brick.brickStrength == 1) {
                        brick.brickImg.src = 'Img/brick.png';
                    } else if (brick.brickStrength == 2) {
                        brick.brickImg.src = 'Img/stone.png';
                    } else {
                        brick.brickImg.src = 'Img/dimond.png';
                    }

                    drawImg(brick.brickImg, brick.brickXpos, brick.brickYpos, brick.brickWidth, brick.brickHeight);



                    if (brick.brickYpos + brick.brickHeight >= ball.ballYpos &&
                        ball.ballYpos + ballDiameter >= brick.brickYpos + brick.brickHeight + ballDiameter / 2 && //possibly plus 4
                        ball.ballXpos + ballDiameter >= brick.brickXpos &&
                        ball.ballXpos <= brick.brickXpos + brick.brickWidth &&
                        ball.ballYspeed < 0 // so ball doesn't hit corner and continue going

                    ) { //hitting the bottom of bricks

                        if (brick.brickStrength < 2) {
                            brickCount -= 1;
                            delete bricks[counter - 1];
                            bricks = bricks.filter(item => item !== undefined); // deltes brick all lowers brick strength if brick can take more than one hit

                        } else {
                            brick.brickStrength -= 1;
                        }

                        if (ball.ballYspeed < 0) {
                            ball.ballYspeed *= -1;

                        }

                    } else if (ball.ballYpos <= brick.brickYpos - ballDiameter / 2 && //possibly plus 4
                        brick.brickYpos <= ball.ballYpos + ballDiameter &&
                        ball.ballXpos + ballDiameter >= brick.brickXpos &&
                        ball.ballXpos <= brick.brickXpos + brick.brickWidth &&
                        ball.ballYspeed > 0) { //hitting top of bricks

                        if (brick.brickStrength < 2) {
                            brickCount -= 1;
                            delete bricks[counter - 1];
                            bricks = bricks.filter(item => item !== undefined);
                        } else {
                            brick.brickStrength -= 1;
                        }

                        if (ball.ballYspeed > 0) {

                            ball.ballYspeed *= -1;
                        }
                    } else if (ball.ballXpos + ballDiameter >= brick.brickXpos &&
                        ball.ballXpos < brick.brickXpos - ballDiameter / 2 &&
                        ball.ballYpos <= brick.brickYpos + brick.brickHeight &&
                        ball.ballYpos + ballDiameter >= brick.brickYpos && //hiting left side of bricks
                        ball.ballXspeed > 0
                    ) {

                        if (brick.brickStrength < 2) {
                            brickCount -= 1;
                            delete bricks[counter - 1];
                            bricks = bricks.filter(item => item !== undefined);
                        } else {
                            brick.brickStrength -= 1;
                        }

                        if (ball.ballXspeed > 0)
                            ball.ballXspeed *= -1;

                    } else if (ball.ballXpos <= brick.brickXpos + brick.brickWidth &&
                        ball.ballXpos + ballDiameter > brick.brickXpos + brick.brickWidth + ballDiameter / 2 &&
                        ball.ballYpos <= brick.brickYpos + brick.brickHeight &&
                        ball.ballYpos + ballDiameter >= brick.brickYpos && //hiting right side of bricks
                        ball.ballXspeed < 0
                    ) { // right side of bricks

                        if (brick.brickStrength < 2) {
                            brickCount -= 1;
                            delete bricks[counter - 1];
                            bricks = bricks.filter(item => item !== undefined);
                        } else {
                            brick.brickStrength -= 1;
                        }


                        if (ball.ballXspeed < 0)
                            ball.ballXspeed *= -1;

                    } else {
                        //not sure if i need this or not
                    }
                });
            });



        }






        function addBrick() {





            //               if (brickCount<=columnCount) {
            //                   brickYpos = 50;
            //                   brickXpos= (canvas.width*0.2) * brickCount;
            //               }   else {
            //                   brickYpos = 50 + brickGap + brickHeight*(rowCount-1);
            //                   brickXpos = (canvas.width*0.2) * (brickCount-6) ;
            //               }


            //            




            rowCount = Math.floor(brickCount / columnMaxCount); // chamges rowCount varibale so when new brick is added it knows where to put it.



            columnCount = brickCount - (columnMaxCount * (rowCount)); // chamges columnCount varibale so when new brick is added it knows where to put it.


            brickXpos = (canvas.width * (1 / columnMaxCount)) * columnCount;

            brickYpos = brickTopGap + brickYgap * rowCount + brickHeight * rowCount;


            brickWidth = canvas.width / columnMaxCount - brickXgap;

            brickHeight = canvas.height * 0.55 / rowMaxCount - brickYgap;

            brickStrength = brickStrength; //decides how many times brick needs to be hit to break
            if (level >= 4) {
                rand();
            }
            if (brickStrength == 1) {
                brickImg.src = 'Img/brick.png';
            } else if (brickStrength == 2) {
                brickImg.src = 'Img/stone.png';
            } else {
                brickImg.src = 'Img/dimond.png';
            }



            var newBrick = {
                brickImg: brickImg,
                brickStrength: brickStrength,
                brickXpos: brickXpos,
                brickYpos: brickYpos,
                brickWidth: brickWidth,
                brickHeight: brickHeight
            }

            console.log('newbrick');
            brickCount += 1;
            return newBrick;

        }

        function drawScore() {
            ctx.font = "30px Times New Roman";
            ctx.fillStyle = "red";
            ctx.fillText("level: " + level, 15, 30); //draws the level level ocunt and lifes
            ctx.fillText("lifes: " + lifes, canvas.width / 3, 30);
            ctx.fillText("lifes: " + lifes, canvas.width / 3, 30);
            if (gameActive == true) {
                score += 1;
            }


        }


        function drawImg(src, x, y, w, h) { //to draw images source,xpos , ypos, height
            ctx.drawImage(src, x, y, w, h);
        }

        function drawCircle(x, y, d, a, b, c) {


            ctx.beginPath();

            ctx.fillStyle = c;
            ctx.arc(x, y, d, a, b); // was used before dicided was easyier to make as a squar images and made hitboxes way more doable.
            ctx.closePath();
            ctx.fill();

        }



        function colorRect(x, y, w, h, c) { //to draw things
            ctx.fillStyle = c;
            ctx.fillRect(x, y, w, h);
        }



        function gameOver() {
            if (lifes < 1) {
                //                alert('Game Over')

            }
        }

        function ballMove() { //makes the ball move


            balls.forEach(function(ball, index, array) { //uese for each so can have muitiple on page at 1 

                ball.ballXpos += ball.ballXspeed;
                ball.ballYpos += ball.ballYspeed;

                if (ball.ballXpos + ballDiameter > canvas.width) { //stop the ball geting stuck in the right wall
                    ball.ballXpos = canvas.width - ballDiameter;
                }

                if (ball.ballXpos < 0) { //stops ball getiing stuck in the left ball
                    ball.ballXpos = 0;
                }

                if (ball.ballXpos + ballDiameter >= canvas.width) { //right wall bounce
                    ball.ballXspeed *= -1;
                }

                if (ball.ballXpos <= 0) { //left wall bounce
                    ball.ballXspeed *= -1;
                }



                if (ball.ballYpos <= 0) {
                    ball.ballYspeed *= -1;
                }

                if (ball.ballYpos + ballDiameter >= paddleYpos && //ball collision with paddle
                    ball.ballYpos < paddleYpos - ball.ballDiameter / 2 &&
                    ball.ballXpos + ballDiameter > paddleXpos &&
                    ball.ballXpos < paddleXpos + PADDLE_WIDTH) {
                    if (ball.ballYspeed > 0) {

                        ball.ballYspeed *= -1;
                        ball.ballXspeed = ((ball.ballXpos + ballDiameter / 2) - (paddleXpos + PADDLE_WIDTH / 2)) / 3.5;

                    }

                }

                if (ball.ballXpos + ballDiameter >= paddleXpos &&
                    ball.ballXpos < paddleXpos - ballDiameter / 3 &&
                    ball.ballYpos <= paddleYpos + PADDLE_HEIGHT &&
                    ball.ballYpos + ballDiameter >= paddleYpos + PADDLE_HEIGHT / 2 && //hiting left side of paddle
                    ball.ballXspeed > 0) {


                    ball.ballXspeed *= -1;

                }

                if (ball.ballXpos <= paddleXpos + PADDLE_WIDTH &&
                    ball.ballXpos + ballDiameter > paddleXpos + PADDLE_WIDTH + ballDiameter / 3 &&
                    ball.ballYpos <= paddleYpos + PADDLE_HEIGHT &&
                    ball.ballYpos + ballDiameter >= paddleYpos + PADDLE_HEIGHT / 2 && //hiting right side of paddle
                    ball.ballXspeed < 0) {
                    ball.ballXspeed *= -1;
                }



            });
            //paddle contact with brick}


        } // end of ballMove function



        function drawBalls() { //draws the ball
            var b = 0;

            balls.forEach(function(ball) {
                b++;
                drawImg(ball2, ball.ballXpos, ball.ballYpos, ball.ballDiameter, ball.ballDiameter);

                //            drawCircle(ballXpos,,ballDiameter,a,b,ballColor);



                if (ball.ballYpos + ball.ballDiameter >= canvas.height + 20) { //floor detecion
                    ball.ballYspeed *= -1;

                ////           delete bricks[counter-1];
                ////       bricks = bricks.filter(item => item !== undefined);


                    delete balls[b-1];
//                    balls = balls.filter(item => item !== undefined);

                    if (ballCount > 0) {

                        ballCount -= 1;
                    } else {
                        lifes -= 1;
                    }

                    if (lifes < 0) {
                        //                    alert('haha your game is over');
                        //                    alert('get shrected scrub');
                        //                    alert('your time is oger');
                    }
                }

                //                        delete balls.ballXspeed;
                //                        delete balls.ballYspeed;
                //                        delete balls.ballXspeed;
                //                        delete balls.ballDiameter;
                //                        delete balls.ballXspeed;
                //                        delete balls.ballYspeed;








                console.log('helllo' + balls);

                //                            delete balls[ballCounter-1];
                //
                ////                             delete bricks[counter-1];
                ////                            bricks = bricks.filter(item => item !== undefined);
                //                            
                //                                balls = balls.filter(item => item !== undefined); // the above line makes the ball undefined this removes that 1




            });
        }



        function newBall() {



            ballXpos = 200;
            ballYpos = 200;
            ballYspeed = ballYspeed;
            ballXspeed = Math.random() * (18 - 7 + 7);
            ballDiameter = 30;



            var newBall = {
                ballXpos: ballXpos,
                ballYpos: ballYpos, //adds new ball so i can have muitiple balls at once.
                ballXspeed: ballXspeed,
                ballYspeed: ballYspeed,
                ballDiameter: ballDiameter
            }

            ballCount += 1;
            console.log('newball')
            return newBall;
        }




        function drawPaddle() { //draws the paddle based on variables that can be changed and are set at start
            colorRect(paddleXpos, paddleYpos, PADDLE_WIDTH, PADDLE_HEIGHT, paddleColor);
        }

        function paddleMove() {


            //            if (paddleXpos > canvas.width * 0.05) {
            //                if (leftKeyPressed == true) {
            //                    paddleXpos -= paddleXspeed;
            //                }
            //            }
            //
            //
            //
            //            if (paddleXpos + PADDLE_WIDTH < canvas.width * 0.95) {
            //                if (rightKeyPressed == true) {
            //                    paddleXpos += paddleXspeed;
            //                }
            //            }
            //        }

            if (paddleXpos >= canvas.width * 0.05 && paddleXpos + PADDLE_WIDTH <= canvas.width * 0.95) {


                if (isNaN(mouseX)) {
                    paddleXpos = canvas.width / 2 - PADDLE_WIDTH / 2;
                } else {
                    paddleXpos = mouseX - PADDLE_WIDTH / 2;
                }



                if (paddleXpos < canvas.width * 0.05) {
                    paddleXpos = canvas.width * 0.05;
                }
                if (paddleXpos + PADDLE_WIDTH > canvas.width * 0.95) {
                    paddleXpos = canvas.width * 0.95 - PADDLE_WIDTH;
                }


            }



        }









        function keyReleased(evt) { // to check if keys are not pressed
            if (evt.keyCode == WKEY || evt.keyCode == TOP_KEY) {
                upKeyPressed = false;
            }

            if (evt.keyCode == AKEY || evt.keyCode == LEFT_KEY) {
                leftKeyPressed = false;
            }

            if (evt.keyCode == SKEY || evt.keyCode == BOT_KEY) {
                downKeyPressed = false;
            }

            if (evt.keyCode == DKEY || evt.keyCode == RIGHT_KEY) {
                rightKeyPressed = false;
            }


        }

        function keyPressed(evt) { // to check if keys are pressed
            if (evt.keyCode == WKEY || evt.keyCode == TOP_KEY) {
                upKeyPressed = true;
            }

            if (evt.keyCode == AKEY || evt.keyCode == LEFT_KEY) {
                leftKeyPressed = true;

            }

            if (evt.keyCode == SKEY || evt.keyCode == TOP_KEY) {
                downKeyPressed = true;
            }

            if (evt.keyCode == DKEY || evt.keyCode == RIGHT_KEY) {
                rightKeyPressed = true;
            }


        }

        function mouseAction(evt) {

            var rect = canvas.getBoundingClientRect();

            var root = document.documentElement;

            mouseX = evt.clientX - rect.left - root.scrollLeft;

            mouseY = evt.clientY - rect.top - root.scrollTop;

            return {

                x: mouseX,

                y: mouseY

            }

        }

    </script>
    <h2> this is bradskines game</h2>


    <style>
        /*
        canvas {
            padding-left:0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
    
*/

    </style>
</body>







<!--
<html>
<head>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
    <meta name="Robots" content="NOINDEX " />
</head>

<body></body>
<script type="text/javascript">
    var gearPage = document.getElementById('GearPage');
    if (null != gearPage) {
        gearPage.parentNode.removeChild(gearPage);
        document.title = "Error";
    }
</script></html>
-->
